--- a/fs/squashfs/Kconfig
+++ b/fs/squashfs/Kconfig
@@ -26,6 +26,11 @@ config SQUASHFS
 
 	  If unsure, say N.
 
+config SQUASHFS_LZMA
+	bool "Include support for LZMA compressed file systems"
+	depends on SQUASHFS
+	select DECOMPRESS_LZMA
+
 config SQUASHFS_EMBEDDED
 
 	bool "Additional option for memory-constrained systems" 
--- a/fs/squashfs/Makefile
+++ b/fs/squashfs/Makefile
@@ -13,6 +13,7 @@
 squashfs-$(CONFIG_SQUASHFS_DECOMP_MULTI_PERCPU) += decompressor_multi_percpu.o
 squashfs-$(CONFIG_SQUASHFS_XATTR) += xattr.o xattr_id.o
 squashfs-$(CONFIG_SQUASHFS_LZ4) += lz4_wrapper.o
+squashfs-$(CONFIG_SQUASHFS_LZMA) += lzma_wrapper.o
 squashfs-$(CONFIG_SQUASHFS_LZO) += lzo_wrapper.o
 squashfs-$(CONFIG_SQUASHFS_XZ) += xz_wrapper.o
 squashfs-$(CONFIG_SQUASHFS_ZLIB) += zlib_wrapper.o
--- a/fs/squashfs/decompressor.c
+++ b/fs/squashfs/decompressor.c
@@ -80,7 +80,11 @@ static const struct squashfs_decompressor *decompressor[] = {
 	&squashfs_lz4_comp_ops,
 	&squashfs_lzo_comp_ops,
 	&squashfs_xz_comp_ops,
+#ifdef CONFIG_SQUASHFS_LZMA
+	&squashfs_lzma_comp_ops,
+#else
 	&squashfs_lzma_unsupported_comp_ops,
+#endif
 	&squashfs_zstd_comp_ops,
 	&squashfs_unknown_comp_ops
 };
@@ -93,9 +97,10 @@
 const struct squashfs_decompressor *squashfs_lookup_decompressor(int id)
 {
 	int i;
+	int idconforming = (id == LZMA_COMPRESSION) ? XZ_COMPRESSION : id;
 
 	for (i = 0; decompressor[i]->id; i++)
-		if (id == decompressor[i]->id)
+		if (idconforming == decompressor[i]->id)
 			break;
 
 	return decompressor[i];
--- /dev/null
+++ b/fs/squashfs/lzma_wrapper.c
@@ -0,0 +1,156 @@
+/*
+ * Squashfs - a compressed read only filesystem for Linux
+ *
+ * Copyright (c) 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009
+ * Phillip Lougher <phillip@lougher.demon.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2,
+ * or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+ *
+ * lzma_wrapper.c
+ */
+
+#include <asm/unaligned.h>
+#include <linux/mutex.h>
+#include <linux/buffer_head.h>
+#include <linux/slab.h>
+#include <linux/vmalloc.h>
+#include <linux/decompress/unlzma.h>
+
+#include "squashfs_fs.h"
+#include "squashfs_fs_sb.h"
+//#include "squashfs_fs_i.h"
+#include "squashfs.h"
+#include "decompressor.h"
+#include "page_actor.h"
+
+struct squashfs_lzma {
+	void	*input;
+	void	*output;
+};
+
+/* decompress_unlzma.c is currently non re-entrant... */
+DEFINE_MUTEX(lzma_mutex);
+
+static void error(char *m)
+{
+	ERROR("unlzma error: %s\n", m);
+}
+
+
+static void *lzma_init(struct squashfs_sb_info *msblk, void *buff)
+{
+	int block_size = max_t(int, msblk->block_size, SQUASHFS_METADATA_SIZE);
+
+	struct squashfs_lzma *stream = kzalloc(sizeof(*stream), GFP_KERNEL);
+	if (stream == NULL)
+		goto failed;
+	stream->input = vmalloc(block_size);
+	if (stream->input == NULL)
+		goto failed;
+	stream->output = vmalloc(block_size);
+	if (stream->output == NULL)
+		goto failed2;
+
+	return stream;
+
+failed2:
+	vfree(stream->input);
+failed:
+	ERROR("Failed to allocate lzma workspace\n");
+	kfree(stream);
+	return ERR_PTR(-ENOMEM);
+}
+
+
+static void lzma_free(void *strm)
+{
+	struct squashfs_lzma *stream = strm;
+
+	if (stream) {
+		vfree(stream->input);
+		vfree(stream->output);
+	}
+	kfree(stream);
+}
+
+
+static int lzma_uncompress(struct squashfs_sb_info *msblk, void *strm,
+	struct buffer_head **bh, int b, int offset, int length,
+	struct squashfs_page_actor *output)
+{
+	struct squashfs_lzma *stream = strm;
+	void *buff = stream->input, *data;
+	int avail, i, bytes = length, res;
+
+//	mutex_lock(&lzma_mutex);
+
+	for (i = 0; i < b; i++) {
+		wait_on_buffer(bh[i]);
+		if (!buffer_uptodate(bh[i]))
+			goto block_release;
+
+		avail = min(bytes, msblk->devblksize - offset);
+		memcpy(buff, bh[i]->b_data + offset, avail);
+		buff += avail;
+		bytes -= avail;
+		offset = 0;
+		put_bh(bh[i]);
+	}
+
+	res = unlzma(stream->input, length, NULL, NULL, stream->output, NULL,
+							error);
+	if (res)
+		goto failed;
+
+	/* uncompressed size is stored in the LZMA header (5 byte offset) */
+	res = bytes = get_unaligned_le32(stream->input + 5);
+	data = squashfs_first_page(output);
+	buff = stream->output;
+	while (data) {
+		if (bytes <= PAGE_SIZE) {
+			memcpy(data, buff, bytes);
+			break;
+		} else {
+			memcpy(data, buff, PAGE_SIZE);
+			buff += PAGE_SIZE;
+			bytes -= PAGE_SIZE;
+			data = squashfs_next_page(output);
+		}
+	}
+	squashfs_finish_page(output);
+
+//	mutex_unlock(&lzma_mutex);
+	return res;
+
+block_release:
+	for (; i < b; i++)
+		put_bh(bh[i]);
+
+failed:
+//	mutex_unlock(&lzma_mutex);
+
+	ERROR("lzma decompression failed, data probably corrupt\n");
+	return -EIO;
+}
+
+const struct squashfs_decompressor squashfs_lzma_comp_ops = {
+	.init = lzma_init,
+	.free = lzma_free,
+	.decompress = lzma_uncompress,
+	.id = LZMA_COMPRESSION,
+	.name = "lzma",
+	.supported = 1
+};
+
--- a/fs/squashfs/xz_wrapper.c
+++ b/fs/squashfs/xz_wrapper.c
@@ -87,6 +87,7 @@
 out:
 	kfree(opts);
 out2:
+	ERROR("Failed to initialize xz options\n");
 	return ERR_PTR(err);
 }
 
@@ -113,7 +113,7 @@
 	return stream;
 
 failed:
-	ERROR("Failed to initialise xz decompressor\n");
+	ERROR("Failed to initialize xz decompressor\n");
 	return ERR_PTR(err);
 }
 
--- a/fs/squashfs/decompressor.h
+++ b/fs/squashfs/decompressor.h
@@ -54,6 +54,10 @@
 extern const struct squashfs_decompressor squashfs_lzo_comp_ops;
 #endif
 
+#ifdef CONFIG_SQUASHFS_LZMA
+extern const struct squashfs_decompressor squashfs_lzma_comp_ops;
+#endif
+
 #ifdef CONFIG_SQUASHFS_ZLIB
 extern const struct squashfs_decompressor squashfs_zlib_comp_ops;
 #endif
--- a/lib/decompress_unlzma.c
+++ b/lib/decompress_unlzma.c
@@ -652,7 +652,9 @@
 
 	if (posp)
 		*posp = rc.ptr-rc.buffer;
+	if (!wr.flush)
+		ret = 0;
+	else if (wr.flush(wr.buffer, wr.buffer_pos) == wr.buffer_pos)
-	if (!wr.flush || wr.flush(wr.buffer, wr.buffer_pos) == wr.buffer_pos)
 		ret = 0;
 exit_3:
 	large_free(p);
